\chapter{Realisierung}
\label{chap:umsetzung}

\section{C-API}
\label{sec:capi_rel}

In folgendem Kapitel wird beschrieben wie die C-\ac{API} genutzt werden konnte, um dem Roboter bestimmte Wegpunkte abzufahren.

\subsection{Beispielanwendung}
\label{sub:capi-problems_rel}

Es konnte eine Anwendung erstellt werden, dass den Roboter Initialisiert und dann in einer Schleife die Positions, Geschwindigkeits und Beschleunigungsdaten sendet. Desweiteren konnte ein Bewegungsprofil errechnet werden, dem der Roboter gefolgt ist.
\\\\
Bevor man Daten vom Roboter Abfragen kann, muss eine Verbindung zum Roboter hergestellt werden, diesem einen hochfahren und initialisieren lassen. Folgend werden diese Vorgänge beschrieben.\\
Mit dem Befehl \sona{robotinterface\_open()} kann die Verbindung zum Roboter hergestellt werden.
\\\\
Um sicher zu gehen das die Verbindung offen ist, wird in einer Schleife eine bestimmte Zeit, immer wieder abgefragt ob der Roboter verbunden ist. Falls dies nicht funktioniert, wird der Vorgang abgebrochen und das Programm sollte beendet werden. Es kommt vor, dass der Roboter beim Starten noch in einem Sicherheitsmodus ist. Wenn dies der Fall ist, muss der Modus abgestellt werden. Dies geht mit der Funktion \sona{robotinterface\_unlock\_security\_stop();}.
\\\\
Auch hier wird zur Sicherheit eine bestimmte Zeitschleife der Befehl wiederholt an den Roboter gesandt. Wenn der Roboter dennoch in dem Sicherheitsmodus ist, ist es möglich, dass der Notausschalter am Touch Tablet aktiviert ist.
Nachdem die Verbindung offen ist, muss der Roboter mit Strom versorgt werden. Mit dem Befehl \sona{robotinterface\_power\_on\_robot()} kann das Bewerkstelligt werden. Auch hier wird eine bestimmte Zeitschleife abgewartet, bis der Roboter hochgefahren ist. Abgefragt werden kann dies mit der Funktion \sona{robotinterface\_is\_power\_on\_robot()}.
\\\\
Nun wird der Roboter Initialisiert. Der Roboter geht nach dem Starten automatisch in den Initialisierungs Modus. Jeder einzelne Joint muss nun solang in eine Richtung bewegt werden, bis der Joint in den normalen Modus übergeht. Um die Gelenke zu bewegen, wird eine Geschwindigkeitsvorgabe an den Roboter gesandt.(siehe Listing \ref{lst:initialize_robot_lst})

\begin{lstlisting}[language=C,caption={Initialisierung der einzelnen Gelenke}, label=lst:initialize_robot_lst,captionpos=b]
puts("Initializing robot");
/// Set zero velocity and acceleration as guard
int j;
for (j=0; j<6; ++j) {
  pva_packet.velocity[j] = 0.0;
  pva_packet.acceleration[j] = 0.0;
}
do {
  ++i;
  robotinterface_read_state_blocking();
  int j;
  for (j=0; j<6; ++j) {
    // initialize_direction is 1 or -1. it determines in which direction die Joint is moving during the initialization
    pva_packet.velocity[j] = ((robotinterface_get_joint_mode(j) == JOINT_INITIALISATION_MODE)) ? (initialize_direction)* 0.1 : 0.0;
   }
  robotinterface_command_velocity(pva_packet.velocity);
  robotinterface_send();
} while (robotinterface_get_robot_mode() == ROBOT_INITIALIZING_MODE && exit_flag == false);
puts(" Done!");
\end{lstlisting}

Nachdem die Initialisierung abgeschlossen ist, muss wie in Listing \ref{lst:robot_control_loop} eine Schleife mit der vorgegebenen Struktur durchlaufen werden, bis das Programm beendet, oder die Verbindung zum Roboter geschlossen werden soll. Wenn dies nicht so gemacht wird, geht der Roboter automatisch in den Sicherheitsstopp, da nicht innerhalb von 8 Millisekunden Nachrichten an den Roboter gesendet wurden.
\\\\
Innerhalb der beiden Befehlen \sona{robotinterface\_read\_state\_blocking()} und \sona{robotinterface\_send()} kann nun eine Interpolation berechnet werden und die Vorgaben für Position, Geschwindigkeit und Beschleunigung an den Roboter gesandt werden(siehe Listing \ref{lst:interpolate}).

\begin{lstlisting}[language=C,caption={Interpolation eines berechneten Wegs}, label=lst:interpolate,captionpos=b]
// loop through interpolation length  
for(i=0; i < move_pva_packet.interpolations+1; i++){
  robotinterface_read_state_blocking();

  // abort interpolation if Robot is in securitystop mode
  if(robotinterface_is_security_stopped()) {
      robotinterface_get_actual_current(currents_actual);
      robotinterface_command_empty_command();
      robotinterface_send();
      break;
  }

  // get current time of interpolation 
  move_pva_packet.point_in_time= (double) i * T_IPO;

  // interpolate with sinoide profile and write result in variable move_pva_packet
  interpolation_sin_ptp(&move_pva_packet);

  // write the triple to robot
  robotinterface_command_position_velocity_acceleration(move_pva_packet.pva.position,
                                                        move_pva_packet.pva.velocity,
                                                        move_pva_packet.pva.acceleration);
  // send command to robot
  robotinterface_send();
}
\end{lstlisting}

\subsection{Interpolation}
\label{sub:interpolation_rel}

TODO interpolation !!

\subsection{Aufgetretene Probleme}
\label{sub:capi-problems_rel}

Der Roboter geht ab einem bestimmten Winkel in den Sicherheitsstopp. Die Abweichung der Position wird zu groß. Dies kann analysiert werden, wenn man sich den Durchschnitt der Soll-Werte und der Ist-Werte der Position ansieht(siehe Abbildung \ref{fig:position_join1}).
\\
\begin{figure}[H]
  \centering
    \includegraphics[width=0.6\textwidth]{pic/joint1_position_capi.png}
      \caption[Soll-und Ist-Werte der Position]{Abbildung zeigt die Soll und Ist Werte der Position, bis zum Sicherheitsstop des Roboters}
      \label{fig:position_join1}
\end{figure}

Die Abweichung steigt beim 2. Gelenk hoch. Die Motorleistung reicht anscheinend nicht aus um über die Schwelle der Reibungskräfte und die Erdanziehung zu kommen. Zu sehen ist in Abbildung \ref{joint1_current_capi.eps}, dass für die Stromstärke ein Offset mitberechnet wird. Vergleicht man die Wert, die bei der selben Bewegung von Polyscope berechnet werden(siehe Abbildung \ref{current_profile_joint1_rci}), sieht man eine höhere Stromstärke bei der Polyscope Software, bei der die Bewegung ohne Probleme Funktioniert.

Mit der C-\ac{API} ist es nicht möglich selbst den wert der Stromstärke vorzugeben, deswegen sind die Soll-Werte bei der Polyscope Software und der eigenen Anwendung mit der C-API etwas verschieden.

\section{Polyscope}
\label{sec:Polyscope_rel}

\subsection{Programmierung}
\label{sub:programmierung_polyscope_rel}

Die Programmierung findet meist nur auf dem Touch Tablet statt. Ein neues Programm fängt mit einem leeren Ereignisbaum an. Es kann per Toucheingabe alle möglichen Funktionen, die die Script Sprache bietet dem Baum hinzugefügt werden. Wenn das Programm abläuft, werden von der Wurzel an die Befehle abgearbeitet.
Wie in Abbildung \ref{fig:programm_in_polyscope} zu sehen ist, ist die Ansicht des Programmbaumes sehr unübersichtlich.

\begin{figure}[H]
  \centering
    \includegraphics[width=0.5\textwidth]{pic/polyscope_program_tree.png}
      \caption[Programm Baum in Polyscope]{Ein Ausschnitt aus einem Programm Baum in Polyscope}
      \label{fig:programm_in_polyscope}
\end{figure}

Es ist möglich andere Script Dateien in das Programm einzufügen. Dazu gibt es ein Feld \sona{Script}. Das Script Programm muss sich auf dem Linux Rechner befinden. Es ist also nötig das Script Programm auf einem anderen Rechner zu programmieren und bei jeder Änderung auf den Linux Rechner des Roboters zu senden. Mit dieser Möglichtkeit könnten Programmabschnitte ausgelagert werden. Es ist aber nicht Übersichtlich welche Script Dateien benutzt werden.\\
Alternativ zu dem Touch Tablet, könnte der X-Server von dem Linux Rechner auf ein anderen Rechner umzuleiten um dort mit dem Programm per Maus und Tastatur zu arbeiten. Dies wurde aber noch nicht getestet und könnte zu verzögerungen beim ausführen kommen.
\\
Eine andere Möglichkeit ein Programm unter Polyscope zu programmieren gibt es nicht.

\subsection{Benutzer Interaktion}
\label{user_interaktion_polyscope_rel}

Die Möglichkeiten zur Interaktion mit dem Benutzer sind sehr begrenzt. Die Software und die URScript Sprache lassen es zu, dass auf dem Touch Tablet \ac{Popup} Nachrichten auftauchen. Wenn man mit dem Benutzer Interagieren will, gibt mehrere Arten dieser \ac{Popup}s.
Als Nachricht, ja/nein Fragen, oder Text abfragen. Der Benutzer kann dann mit einen Text oder wählen zweier ja/nein Buttons antworten. In Abbildung \ref{polyscope_popup} ist als Beispiel eine Nachricht und eine Ja/Nein \ac{Popup} zu sehen.

\begin{figure}[H]
  \centering
    \includegraphics[width=0.8\textwidth]{pic/popup_question.png}
      \caption[Popup in Polyscope]{Abbildung zeigt Zwei verschiedene Arten von Popups in Polyscope}
      \label{fig:polyscope_popup}
\end{figure}

Kompliziertere Menüs sind mit dieser Methode nicht möglich. Wenn ein Programm erstellt werden soll, bei dem der Benutzer viele eingaben machen muss, ist es mit Polyscope sehr schwer das zu realisieren.

\subsection{Test und Fehlersuche im Programm}
\label{debuggin_polyscope_rel}

Bevor Polyscope ein Programm ablaufen lässt wird das Script auf die richtige Syntax geprüft. Sollte ein Fehler vorhanden sein wird dies beim Start als \ac{Popup} angezeigt. Fehler die in Abschnitten mit Touch hinzugefügt wurden, können jedoch nicht lokalisiert werden. Nur in extra eingefügtem Script Code kann grob lokalisiert werden, welcher Fehler aufgetreten ist, weil dieser Teil extra geprüft wird.
\\\\
Da das Programm mit dem Touch Tablet ausgeführt werden kann, ist es möglich während der Programmierung das Programm ablaufen zu lassen. Es kann sehr schnell getestet werden ob die gewünschten Einstellungen dem Ergebnis entsprechen. Bei Großen Programmen mit vielen Benutzeranfragen, kann dies jedoch viel Zeit in Anspruch nehmen. Es muss von einem Benutzer bei jeder Anfrage eines \ac{Popup}s von Hand geantwortet werden.

\subsection{Aufwand der Programmierung}
\label{polyscope_aufwand}

Kleine Programme in Polyscope sind sehr schnell geschrieben. Mit dem Touch Tablet kann sehr schnell eine kleine Kontrollstruktur aufgebaut werden. Das Tablet hat jedoch große Nachteile. Wie in Abbildung \ref{polyscope_program_tree} zu sehen ist der Bereich für den Ereignisbaum sehr klein. Wenn ein Programm nun z. B. 500 Befehle enthält, ist es nicht möglich ein Überblick zu halten. Auch ist es sehr aufwändig zwischen bestimmten Bereichen hin und her zu Wechseln, da das Touch Tablet nicht genau ist. Möglich ist es geschriebene Bereiche auf Script Dateien zu verschieben, die dann im Polyscope Programm verwendet werden. 

\subsection{TCP Server mit Datenbank zum dauerhaften speichern der Daten}
\label{tcp_datentank_sicherung_rel}

Um mit Polyscope und URScript erhobene Daten zu Speichern wurde ein kleiner \ac{TCP/IP} Server geschrieben, der eine Verbindung zulässt und Daten in einer Datenbank speichert. Die Daten sind Objektorientiert, und werden von dem Server erstellt.
In Polyscope und URScript gibt es keine Objektorientierung, deshalb muss dort alles nacheinander angefragt werden.
Ein Beispiel einer \ac{TCP/IP} Servers liegt im Anhang(siehe \ref{save_data_tcp_code_gru})

\section{URScript}
\label{sec:ur_script_rel}

Die URScript Sprache ist sehr stark an Python gelehnt.
Das Manual von Univeral Robots umfasst alle nötigen Funktionen um Komplexe Aufgaben zu Erfüllen.
Um Daten persistent zu speichern, muss wie in Polyscope eine \ac{Socket} Verbindung zu einer Zweiten Anwendung aufgebaut werden, die die Daten speichert(siehe \ref{tcp_datentank_sicherung_rel})

\subsection{Laden des Scripts auf den Controller}
\label{load_script_rel}

Das Script kann nicht direkt auf dem Rechner über die Polyscope Software ausgeführt werden. Um ein selbst geschriebenes Programm in URScript auszuführen ist es nötig sich mit der Secondary Schnittstelle des URControllers \ref{urcontrol_spi_gru} per \ac{TCP/IP} zu verbinden und dann die Einzelnen Zeilen der Script Datei an den Controller zu senden.
\\\\
Es ist möglich einzelne Befehle oder ein großes Programm auszuführen. Um einzelne Befehle auszuführen, werden diese nacheinander versendet.
Ein ganzes Programm wird versendet, indem wie in Listing \ref{lst:urscipt_program_lst} gezeigt eine Funktion die ganzen Befehle umschließt. Der Controller führt diese Funktion aus, sobald diese mit dem ``end'' der Funktion abgeschlossen ist.
Zu beachten ist noch, dass der URcontroller am Ende jeden Befehls oder Programm's ein Zeilenumbruch erwartet.

\begin{lstlisting}[caption={Kleines Beispielprogramm in URScript}, label=lst:urscipt_program_lst ,captionpos=b] 
def myProg():
	popup("hello world","test", False, False)
	set_digital_out(1, True)
	movej([0.23,1.23,0.343,0.34.0.0,0.0],a=0.5,v=0.3)
end
\end{lstlisting}

\subsection{Programmierung}
\label{programmierung_ur_script_rel}

Programmiert werden kann das Script mit allen vorhandenen Textverarbeitungsprogrammen. Vorteilhaft ist es, wenn das Programm \acs{Syntax Highligting} für Python beherrscht Da URScript sehr stark an Python angelehnt ist, hilft dies ein wenig den Überblick zu behalten.
\\Die Sprache bietet keine möglichkeiten Kommentare zu nutzen, was aber sehr wichtig ist, wenn ein Programm wächst und mehrere Programmierer am Projekt beteiligt sind. Es ist wichtig für die verständlichkeit. Deshalb wurde dafür in dem Programm, welches das URScript liest und an die Schnittstelle sendet, ein Pre-Prozessor eingebaut. Die Script Datei wird nach Kommentaren durchsucht und schneidet diese vor dem senden raus.(siehe \ref{lst:urscipt_comment_lst})

\begin{lstlisting}[caption={Beispiel-Kommentare vor und nach dem Pre-Prozessor}, label=lst:urscipt_comment_lst ,captionpos=b]
  def testprog():
    # mit # wird ein Kommentar angefangen
    movej([0.23,1.23,0.343,0.34.0.0,0.0],a=0.5,v=0.3) # Bewegung auf Achs Ebene zur Startposition
  end

  wird zu 

  def testprog():
    movej([0.23,1.23,0.343,0.34.0.0,0.0],a=0.5,v=0.3)
  end

\end{lstlisting}

\subsection{Test und Fehlersuche im Programm}
\label{ur_script_debuggen}

Nach dem Senden des Programms an den URController, ist die einzige Möglichkeit zu sehen ob das Programm Fehler enthält, wenn der Controller ein entsprechendes Bit setzt, das in den Datenpaketen von der Secondary Schnittstelle gesendet wird. Über dieses \sona{Programm läuft} Bit, kann man sehen ob ein Programm läuft oder nicht läuft. 
\\Man erhält keine Nachrichten was nicht in Ordnung ist, falls das Script Programm nicht abläuft. Um Fehler auszuschließen muss also der Bereich isoliert werden, indem der Fehler vorkommt. Das geht meist nur in einem aufwändigem ausschluss Verfahren, bei dem immer wieder Scriptcode entfernt wird.

\subsection{Benutzer Interaktion}
\label{ur_script_user_interaction}

Das Manual für URScript nennt nur die \ac{Popup} Funktion um dem Anwender eine Nachricht zu geben. Andere Möglichkeiten zur Interaktion ist im Manual nicht angegeben. Jedoch bietet Polyscope auch über verschiedene \ac{Popup} Arten möglichkeiten zur Interaktion. Diese \ac{Popup}s gibt es auch für URScript. Die Befehle können aus dem von Polyscope erzeugtem URScript Code von \ac{URP} Programmen eingesehen werden. Somit bestehen genau die gleichen Möglichkeiten wie bei Polyscope.

\subsection{Aufwand der Programmierung}
\label{ur_script_aufwand}

Im Gegensatz zur Polyscope Software, kann mit einem Textverarbeitungsprogramm sehr schnell mit guter Übersicht ein größeres komplexeres Programm erstellt werden. Es können auch leicht Kommentare eingefügt werden und der Code ist im späteren Fall leichter verständlich für neue Programmierer. Da schwer Fehler zu entdecken sind und deswegen häufig das Programm manuell getestet werden muss, ist dennoch bei großen Anwendungen ein größerer zeitlicher Aufwand von Nöten

\section{Anwendung mit Adapter zu URScript}
\label{sec:script_hoerherer_schicht_rel}

Im folgenden Kapitel wird das Anwendungsbeispiel in Python entwickelt. Um zu zeigen, wie die Benutzerinteraktion mit einem Eigenen Adapter gestaltet werden kann, wurde hierfür die Software Bibliothek \sona{TKinter}\footnote{Mehr Informationen über TKinter unter folgender Website: \url{https://wiki.python.org/moin/TkInter}}, mit der man sehr schnell eine \ac{GUI} entwickeln kann. Die Interaktion erfolgt durch Buttons, die dann über den Adapter Befehle an den Roboter sendet.

\subsection{Adapter zur Secondary Schnittstelle}
\label{beschreibung_script_hoeher_schicht}

Die Script befehle zur Secondary Schnittstelle, werden als Text übergeben. Der Adapter, wird in Form einer Klasse geschrieben, die die einzelnen Script Befehle in Funktionen mitliefert(siehe Listing \ref{lst:secondary_interface_scriptfunctions}).

\begin{lstlisting}[caption={Ausschnitt zeigt Funktionen, die Scriptbefehle in der Adapter Klasse umgesetzten}, label=lst:urscipt_program_lst ,captionpos=b]

# moveJ moves the Robot with joint coordinates
# positions should include the target joint positions
def movej(self, positions=None, a_max=None, v_max=None):
    if positions is None:
        positions= self.get_joint_positions()
    if a_max is None:
        a_max=math.radians(40)
    if v_max is None:
        v_max=math.radians(60)
    message="""movej(%s,a=%f,v=%f)
    """%(positions,a_max,v_max)
    print message
    self.start_program(message)

# movel moves the Robot Linear in kartesian coordinates
# positions should contain the target tcp positions
def movel(self, positions=None, a_max=None, v_max=None):
    if positions is None:
        positions= self.get_tcp_positions()
    if a_max is None:
        a_max=math.radians(40)
    if v_max is None:
        v_max=math.radians(60)
    message="""movel(p%s,a=%f,v=%f)
    """%(positions, a_max, v_max)
    print message
    self.start_program(message)
\end{lstlisting}

Diese Klasse öffnet zwei Verbindungen zur Secondary Schnittstelle. Eine zum Empfangen der Datenpakete und eine zum Senden der URScript Befehle. Der Adapter besitzt eine \ac{Queue} um die Befehle, nacheinander zur Secondary Schnittstelle zu senden. Da Befehle eventuell viel Zeit benötigen, um ausgeführt zu werden, wird gewartet bis der Befehl abgearbeitet oder abgebrochen wurde. Erst dann wird in der Queue der nächste Befehl an die Schnittstelle gesendet.

\begin{lstlisting}[caption={Ausschnitt zeigt die Abarbeitung der Queue}, label=lst:adapter_queue ,captionpos=b] 
while self.__run_flag:
    DequePrograms.lock.acquire()
    if(len(self.s_interface.program_queue) > 0):
        # print("message queue contains messsages %d" % len(self.s_interface.program_queue))
        message=self.s_interface.program_queue.popleft()
    else:
        message=None
    DequePrograms.lock.release()
    if(message is not None):
        SecondSendInterface.send_lock.acquire()
        self.s_interface.send_messages_queue.append(message)
        SecondSendInterface.send_lock.release()

        //blocks the thread until URScript finishes
        self.s_interface.block_program()
    time.sleep(0.2)
return 0
\end{lstlisting}

Schnittstelle und arbeitet nacheinander eine \ac{Queue} ab, die Befehle an die Schnittstelle beinhaltet.
In einer Anwendung kann nun diese Klasse benutzt werden um den Roboter zu steuern.
Der Aufwand für ein Programm ist mit einer Eigenen API anfangs deutlich höher als die URScript Sprache direkt zu nutzen. Es muss erst ein Adapter geschrieben und getestet werden, bevor die eigentliche Anwendung geschrieben werden kann. 

\subsection{Programmierung mit Adapter}
\label{programmierung_mit_hoerherer_schicht}

Sobald der Adapter in einer etablierten Programmiersprache programmiert ist, und Fehler in diesem so gut wie ausgeschlossen sind, kann nun mit normalen Softwareentwicklungstechniken leicht ein Programm geschrieben werden. In dieser Arbeit wurde Python gewählt. Python bietet viele Bibliotheken und Design Patterns die das Programmieren vereinfacht. Es können Entwicklungswerkzeuge benutzt werden um einen leichten Überblick über das Programm zu behalten.

\subsection{Benutzer Interaktion}
\label{user_interaktion_mit_hoerherer_schicht}

Eine etablierte Programmiersprache bietet natürlich auch alle möglichen Bibliotheken und Möglichkeiten ein interaktives und leicht verständliches Interface zu erstellen. Es ist möglich übersichtliche Formulare zu erstellen mit denen Informationen vom Anwender zu erfassen. Abbildung \ref{fig:hda_urcontrol_gui} zeigt ein Interface, mit dem der Roboter primitiv in alle Richtungen gesteuert werden kann. Für eine Umsetzung von allen Möglichkeiten wurde wegen Zeitmangels verzichtet.

\begin{figure}[H]
  \centering
    \includegraphics[width=0.8\textwidth]{pic/hda_urcontrol_gui.png}
      \caption[Selbsterstelltes GUI zur Steuerung des UR5 Roboters]{Startfenster des selbst erstellten GUI's zur Steuerung des UR5 Roboters. Es ist möglich den Roboter in alle Richtungen Linear zu bewegen.}
      \label{fig:hda_urcontrol_gui}
\end{figure}

\subsection{Test und Fehlersuche im Programm}
\label{debuggen_mit_hoeherer schicht}

Nach Ausschluss der Fehler in dem Adapter, kann in der Programmiersprache vorhandene \ac{Unittest} oder andere automatische Tests für das Programm verwendet werden. Die Schnittstelle zum Roboter wird hier durch einen sogenannten \ac{Mock} erstetzt. Dadurch kann auch offline getestet werden. Fehler werden in den etablierten Programmiersprachen so leichten gefunden und lokalisiert. \ac{Interpreter} Programmiersprachen analysieren den Softwarecode auf Fehler in der Syntax, bevor sie ihn ausführen. Auch Sprachen die keine \ac{Interpreter} benutzen und den Softwarecode Kompilieren, testen den Code auf Syntaxfehler und zeigen Fehler frühzeitig an.

\subsection{Aufwand der Programmierung}
\label{eigene_api_aufwand}

Der Aufwand für ein Programm ist mit einer Eigenen API anfangs deutlich höher, gegenüber den anderen Methoden. Es muss erst ein Adapter geschrieben und getestet werden, bevor die eigentliche Anwendung geschrieben werden kann. 
Nach dieser Hürde, ist es aber sehr leicht Programme zu erstellen die auf den Adapter zugreifen um den Roboter zu steuern.